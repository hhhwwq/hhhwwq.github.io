---
title: apply，bind，call的区别；new；this；闭包 
date: 2019-10-22 11:36:05
tags: "JavaScript"

---


防抖和节流;作用域和作用域链;DOM;Array.sort();Ajax
========================


防抖和节流 
--------------


### 节流概念(Throttle) 

按照设定的时间固定执行一次函数，比如200ms一次。注意：固定就是你在mousemove过程中，执行这个节流函数，它一定是200ms（你设定的定时器延迟时间）内执行一次。没到200ms，一定会返回，没有执行回调函数的。

主要应用场景有：scroll、touchmove

### 防抖概念(Debounce) 

抖动停止后的时间超过设定的时间时执行一次函数。注意：这里的抖动停止表示你停止了触发这个函数，从这个时间点开始计算，当间隔时间等于你设定时间，才会执行里面的回调函数。如果你一直在触发这个函数并且两次触发间隔小于设定时间，则一定不会到回调函数那一步。

主要应用场景有：input验证、搜索联想、resize

作用域和作用域链、执行期上下文 
----------------------------------

### 作用域

js只有函数作用域（function-based），没有块级作用域，也就是只有函数会有自己的作用域，其他都没有。

接着，作用域分为全局作用域与局部作用域。

全局作用域中的对象可以在代码的任何地方访问，一般来说，下面情况的对象会在全局作用域中：

-   最外层函数和在最外层函数外面定义的变量
-   没有通过关键字”var”声明的变量
-   浏览器中，window对象的属性

**局部作用域**又被称为函数作用域（Function scope），所有的变量和函数只能在作用域内部使用。

    var foo = 1;
    window.bar = 2;

    function baz(){
        a = 3;
        var b = 4;
    }
    // Global scope: foo, bar, baz, a 
    // Local scope: b

在创建这个函数的时候，这个函数的作用域与作用域链（函数的作用域链将会在运行时用到）就已经决定了，而不是在调用的时候。

### 作用域链

内部[[Scope]]属性包含一个函数被创建的作用域中对象的集合。此集合被称为函数的作用域链，它决定哪些数据可以由函数访问。

### 执行上下文

在JavaScript中有三种代码运行环境：

-   Global Code +JavaScript代码开始运行的默认环境
-   Function Code 代码进入一个JavaScript函数
-   Eval Code 使用eval()执行代码

为了表示不同的运行环境，JavaScript中有一个执行上下文（Execution
context，EC）的概念。也就是说，当JavaScript代码执行的时候，会进入不同的执行上下文，这些执行上下文就构成了一个执行上下文栈（Execution
context stack，ECS）。

### 总结

函数在定义时就会确定他的作用域与作用域链（静态），只有调用的时候才会创建一个执行上下文，其中包含了调用时的形参，其中的函数声明与变量（VO）,
同时创建活动对象（AO），并将AO压入执行上下文的作用域链的最前端并且包含了this的属性，执行上下文的作用域链是通过正在被调用函数的作用域链得到的（动态）。

DOM常见的操作方式 
---------------------

### 15.1常用的查找节点的方法有： 

document.getElementById(‘id属性值’); 返回拥有指定id的对象的引用

document.getElementsByClassName(‘class属性值’);
返回拥有指定class的对象集合

document.getElementsByTagName(‘标签名’); 返回拥有指定标签名的对象集合

### 15.2常用的新建节点的方法有： 

document.createElement(‘元素名’); 创建新的元素节点

document.createAttribute(‘属性名’); 创建新的属性节点

document.createTextNode(‘文本内容’); 创建新的文本节点

### 15.3常用的添加新节点的方法有：

1.element.setAttribute(attributeName, attributeValue );
给元素增加指定属性，并设定属性值。

2.element.setAttributeNode(attributeName ); 给元素增加属性节点。

3.如需向HTML
DOM添加新元素，您必须首先创建该元素（元素节点），然后向一个已存在的元素追加该元素。

1)document.createTextNode(‘新增文本内容’); 创建新的文本节点。

2)parent.appendChild(创建的新节点);
向父节点的最后一个子节点后追加新节点，或使用parent.insertBefore(newChild,
existingChild ); 向父节点的某个特定子节点之前插入新节点。

### 15.4常用的删除节点的方法有： 

parentNode.removeChild(existingChild );
删除已有的子节点，返回值为删除节点。

DOM需要清楚你需要删除的元素，以及它的父元素。常用的解决方案：找到你希望删除的子元素，然后使用其parentNode属性来找到父元素：

var
child=document.getElementById(“p1”);child.parentNode.removeChild(child);

### 15.5常用的修改节点的方法有： 

parentNode.replaceChild(newChild, existingChild );
用新节点替换父节点中已有的子节点

element.setAttribute(attributeName, attributeValue );
给元素增加指定属性，并设定属性值(若原元素已有该节点，此操作能达到修改该属性值的目的)

element.setAttributeNode(attributeName );
给元素增加属性节点(若原元素已有该节点，此操作能达到修改该属性值的目的)

Array.sort()方法与实现机制 
------------------------------

定义与用法：

sort() 方法用于对数组的元素进行排序。

语法：

arrayObject.sort(sortby)

注意：sortby必须是函数，规定排序顺序。可选参数

返回值：

对数组的引用。请注意，数组在原数组上进行排序，不生成副本。

说明及原理：

如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。

Ajax请求过程 
---------------

### Ajax是什么

是一种异步请求数据的技术，会带来更好的用户体验。

### Ajax的使用

(1)创建`XMLHttpRequest`对象,也就是创建一个异步调用对象.

(2)创建一个新的`HTTP`请求,并指定该`HTTP`请求的方法、`URL`及验证信息.

(3)设置响应`HTTP`请求状态变化的函数.

(4)发送`HTTP`请求.

(5)获取异步调用返回的数据.

(6)使用JavaScript和DOM实现局部刷新.

      var xmlHttp = new XMLHttpRequest();

        xmlHttp.open('GET','demo.php','true');

        xmlHttp.send()

        xmlHttp.onreadystatechange = function(){

            if(xmlHttp.readyState === 4 & xmlHttp.status === 200){

            }

        }

步骤详解： 1.创建Ajax核心对象XMLHttpRequest

    var xmlhttp;
    if(window.XMLHttpRequest){ 
    //IE7+,Chrome,Firefox,Safari,Opera执行此代码 
        xmlhttp=new XMLHttpRequest;
    }else{
       //IE5,IE6执行该代码
       xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
    }

2.向服务器发送请求

    xmlhttp.open(method,url,async);
    xmlhttp.send();

示例如下：

     xmlhttp.open("GET","http://www.runoob.com/try/ajax/demo_get.php",true);
     xmlhttp.send();

**注意一**：open 的参数要牢记，很多面试官爱问这样的细节
method：请求的类型；GET 或 POST

url：文件在服务器上的位置，相对位置或绝对位置

async：true（异步）或 false（同步）

为什么使用 Async=true ？

我们的实例在 open() 的第三个参数中使用了
“true”,该参数规定请求是否异步处理。

true 表示脚本会在 send() 方法之后继续执行，而不等待来自服务器的响应。

onreadystatechange
事件使代码复杂化了。但是这是在没有得到服务器响应的情况下，防止代码停止的最安全的方法。

通过把该参数设置为 “false”，可以省去额外的 onreadystatechange
代码。如果在请求失败时是否执行其余的代码无关紧要，那么可以使用这个参数。

**注意二**：post请求不同于get请求

send(string)方法post请求时才使用字符串参数，否则不用带参数。

**注意三**：post请求一定要设置请求头的格式内容

    xmlhttp.open("POST","ajax_test.html",true);
    xmlhttp.setRequestHeader("content-type","application/x-www-form-urlencoded");
    xmlhttp.send("fname=Herry&lname=Ford");

3.服务器响应处理

responseText 获得字符串形式的响应数据。 responseXML 获得XML
形式的响应数据。

3.1 同步处理

    xmlhttp.open("GET","http://www.runoob.com/try/ajax/demo_get.php",false);
    xmlhttp.send();
    document.getElementById("mydiv").innerHTML=xmlhttp.responseText;

直接在send()后面处理返回来的数据。

3.2 异步处理

异步处理相对比较麻烦，要在请求状态改变事件中处理。

     xmlhttp.onreadystatechange=function () {//接收到服务端响应时触发
          if(xmlhttp.readyState==4&&xmlhttp.status==200){
                document.getElementById("mydiv").innerHTML=xmlhttp.responseText;
           }
     }

一共有5中请求状态，从0 到 4 发生变化。

0: 请求未初始化

1: 服务器连接已建立

2: 请求已接收

3: 请求处理中

4: 请求已完成，且响应已就绪

xmlhttp.status：响应状态码。这个也是面试比较爱问的，这个必须知道4个以上，比较常见的有：

200: “OK”

304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。

403 （禁止） 服务器拒绝请求。

404 （未找到） 服务器找不到请求的网页。

408 （请求超时） 服务器等候请求时发生超时。

500 （服务器内部错误） 服务器遇到错误，无法完成请求。


