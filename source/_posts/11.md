---
title: apply，bind，call的区别；new；this；闭包 
date: 2019-10-17 10:10:50
tags: "JavaScript"

---

原型和原型链;prototype与proto的关系与区别;继承;深拷贝与浅拷贝
========================



原型和原型链 
---------------

### 一、什么是原型：

任何对象都有一个原型对象，这个原型对象由对象的内置属性\_proto\_指向它的构造函数的prototype指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有prototype，只有方法才有prototype。

        function Person() {
        }
        var p = new Person();
        //方法才有prototype,普通对象无prototype
        console.log(Person.prototype); // Object{} 
        console.log(p.prototype); // undifined

        //任何对象都是有构造函数的,Person这种方法的构造函数是Function。
        //备注:constructor很容易被改变，一般不用它，此处只是打印下列对象的构造函数是什么。

        console.log(p.constructor); //function Person(){}  
        console.log(Person.constructor); //function Function(){} 
        console.log({}.constructor); // function Object(){}
        console.log(Object.constructor); // function Function() {}
        console.log([].constructor);  //function Array(){} 
        那什么是构造函数呢？

用function声明的都是函数，而如果直接调用的话，那么Person()就是一个普通函数，只有用函数new产生对象时，这个函数才是new出来对象的构造函数。

### 二、创建对象的过程（采用new关键） 

2.1 、声明方法的过程

 首先，当我们声明一个function关键字的方法时，会为这个方法添加一个prototype属性，指向默认的原型对象，并且此prototype的constructor属性也指向方法对象。此二个属性会在创建对象时被对象的属性引用。

        function Hello() {
        }
        console.log(Hello.prototype); // Object {} -- > 内部的constructor 指向Hello方法
        console.log(Hello.prototype.constructor); // function Hello(){}

2.2、我们如果用Hello创建一个对象h，看这个对象有什么属性。

        console.log(h.constructor); // function Hello(){}
        console.log(Object.getPrototypeOf(h)==Hello.prototype); // true  备注：getPrototypeOf是获取_proto_

我们惊喜的发现，new出来的对象，它的constructor指向了方法对象，它的\_proto\_和prototype相等。

即new一个对象，它的\_proto\_属性指向了方法的prototype属性，并且constructor指向了prototype的constructor属性。

2.3 、创建一个对象的过程

        function Hehe(name) {
            this.name = name;
        }
        var h = new Hehe("笑你妹");
        //伪代码:
        function newObj(name){
            var obj = {};
            obj.__proto__ = Hehe.prototype; 
            obj.constructor = Hehe.prototype.constructor;
            var result = Hehe.call(obj, name);
            return typeof result==='object'&& result!=null ? result : obj;  //当无返回对象或默认时返回obj。
        }
        var hh = newObj("笑你妹");
        console.log(hh);
        console.log(h);
        //虽然hh!=h,但是可以看到这个hh就和h的结构一样了。

过程：先创建一个空对象，设置一个\_proto\_指向方法的原型，设置constructor，用新对象做this指向方法，返回新对象。

2.4、延伸

从上面说明的过程中，我们发现只要是对象就是有构造函数来创建的，并且内部二个属性是从构造函数的prototype衍生的一个指向，而构造函数的prototype也是一个对象，那么它应该肯定也有一个构造函数，首先它是一个Object
{}
对象，那么它的构造函数肯定是Object,所以就会有一个指针\_proto\_指向Object.prototype。最后Object.prototype因为没有\_proto\_，指向null，这样就构成了一个原型链。

### 三、原型链 

1）什么是原型链？

 原型链的核心就是依赖对象的\_proto\_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到Object时，就没有\_proto\_指向了。

2）如何分析原型链?

因为\_proto\_实质找的是prototype，所以我们只要找这个链条上的构造函数的prototype。其中Object.prototype是没有\_proto\_属性的，它==null。

3.1、最简单的原型链分析

        function Person(name){
                this.name = name;
        }
        var p = new Person();
        //p ---> Person.prototype --->Object.prototype---->null

属性搜索原则：

1.当访问一个对象的成员的时候，会现在自身找有没有,如果找到直接使用。

2.如果没有找到，则去**原型链指向的对象的构造函数的prototype中找**，找到直接使用，没找到就返回undifined或报错。

 prototype与**proto**的关系与区别（） 
--------------------------------------------------------------

**proto**是每个对象都有的一个属性，而prototype是函数才会有的属性!!!
使用Object.getPrototypeOf()代替**proto**!!!

### 10.1、prototype 

几乎所有的函数（除了一些内建函数）都有一个名为prototype（原型）的属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以有特定类型的所有实例共享的属性和方法。prototype是通过调用构造函数而创建的那个对象实例的原型对象。hasOwnProperty()判断指定属性是否为自有属性；in操作符对原型属性和自有属性都返回true。

示例：自有属性&原型属性

    var obj = {a: 1};
    obj.hasOwnProperty("a"); // true
    obj.hasOwnProperty("toString"); // false
    "a" in obj; // true
    "toString" in obj; // true

示例：鉴别原型属性

    function hasPrototypeProperty(obj, name){
        return name in obj && !obj.hasOwnProperty(name);
    }

### 10.2、 —proto— 

对象具有属性**proto**，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。

    function Foo(){}
    var Boo = {name: "Boo"};
    Foo.prototype = Boo;
    var f = new Foo();

    console.log(f.__proto__ === Foo.prototype); // true
    console.log(f.__proto__ === Boo);   // true
    Object.getPrototypeOf(f) === f.__proto__;   // true

继承的实现方式及比较 
------------------------

许多语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链实现的。

### 11.1 原型链 

基本思想为利用原型让一个引用类型继承另一个引用类型的属性和方法。
（1）可以通过两种方式确定原型和实例的关系：instanceof操作符和isPrototypeOf（）方法，只要是原型链中出现过的原型，都可以说时原型链所派生的实例的原型。
（2）应谨慎地定义方法，给原型添加方法的代码一定要放在替换原型的语句之后，而且在通过原型链实现继承时，不能使用对象字面量创建原型方法。

### 11.2 借用构造函数 

在解决原型中包含引用类型值所带来的问题中，开发人员开始使用一种叫做**借用构造函数**的技术，基本思想为在子类型构造函数的内部调用超类型构造函数。
（1）传递参数

    function SuperType(name){
        this.name=name;
    }
    function SubType(){
        //继承了SuperType，同时还传递了参数。
        SuperType.call(this,"Nicholas");
        //实例属性
        this.age=29;
    }
    var instance=new SubType();
    alert(instance.name);       //"Nicholas"
    alert(instance.age);        //29

（2）借用构造函数的问题
构造函数模式始终存在的问题为：方法在构造函数中定义，因此函数复用就无从谈起了。

### 11.3 组合继承（最常用） 

组合继承时指将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。
最大问题为无论在什么情况下都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。

### 11.4 原型式继承 

es5通过新增Object.create()方法规范化了原型式继承，这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。

### 11.5 寄生式继承 

基本思想为创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄生式继承模式。

    function createAnother(original){
        var clone=object(original); //通过调用函数创建一个新对象
        clone.sayHi=function(){     //以某种方式来增强这个对象
            alert("hi);
        };
        return clone;               //返回这个对象
    }

使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率，这一点与构造函数模式类似。

### 11.6 寄生组合式继承 

基本思想为不必为了指定子类型的原型而调用超类型的构造函数。

    function inheritPrototype(subType,superType){
        var prototype=object(superTypr.prototype);  //创建对象
        prototype.constructor=subType;              //增强对象
        subType.prototype=prototype;                //指定对象。
    }

总结：

JavaScript主要通过**原型链实现继承**。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。

**原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。**

解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是**组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实力属性。**

此外，还存在下列可供选择的继承模式。

**原型式继承**，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。

**寄生式继承**，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式和组合模式一起使用。

**寄生组合式继承**，集寄生式继承和组合继承的优点于一身，是实现基于类型继承的最有效方式。

 深拷贝与浅拷贝 
------------------

**赋值**是赋的是该对象的在栈中的地址，而不是堆中的数据，也就是两个对象指向的是同一个存储空间，是联动的；

**浅拷贝**只复制一层对象的属性，如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址
，并不包括对象里面的为引用类型的数据；

**浅拷贝的实现：**
1.Object.assign()：把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象，拷贝的是对象的属性的引用，而不是对象本身。

    var obj = { a: {a: "copy", b: 1} };
    var newlObj = Object.assign({}, obj);//-----------
    initalObj.a.a = "swallow";
    console.log(obj.a.a); //swallow

2.Array.prototype.concat()：修改新对象会改到原对象

    let arr = [1, 2, {    username: 'copy'    }];
    let arr2=arr.concat();//----------------    
    arr2[2].username = 'swallow';
    console.log(arr);

3.Array.prototype.slice()：同样修改新对象会改到原对象

    let arr = [1, 2, {    username: 'copy'    }];
    let arr2=arr.slice();//----------------    
    arr2[2].username = 'swallow';
    console.log(arr);

注：Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。

**深拷贝**是对对象以及对象的所有子对象进行拷贝。

**深拷贝**的实现：

1.JSON.parse(JSON.stringify())：用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，**新的对象产生了，而且对象会开辟新的栈**，可以**实现数组或对象深拷贝**，但**不能处理函数。**

因为JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个
JSON字符串，不能接受函数

    let arr = [1, 3, {    username: ' copy'}];
    let arr2 = JSON.parse(JSON.stringify(arr));
    arr2[2].username = 'shen'; 
    console.log(arr, arr4)

2.递归：递归方法实现深度克隆原理：**遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝。**

     //定义检测数据类型的功能函数
        function checkedType(target) {
          return Object.prototype.toString.call(target).slice(8, -1)
        }
        //实现深度克隆---对象/数组
        function clone(target) {
          //判断拷贝的数据类型
          //初始化变量result 成为最终克隆的数据
          let result, targetType = checkedType(target)
          if (targetType === 'Object') {
            result = {}
          } else if (targetType === 'Array') {
            result = []
          } else {
            return target
          }
          //遍历目标数据
          for (let i in target) {
            //获取遍历数据结构的每一项值。
            let value = target[i]
            //判断目标结构里的每一值是否存在对象/数组
            if (checkedType(value) === 'Object' ||
              checkedType(value) === 'Array') { //对象/数组里嵌套了对象/数组
              //继续遍历获取到value值
              result[i] = clone(value)
            } else { //获取到value值是基本的数据类型或者是函数。
              result[i] = value;
            }
          }
          return result
        }

      // 内部方法：用户合并一个或多个对象到第一个对象
        // 参数：
        // target 目标对象  对象都合并到target里
        // source 合并对象
        // deep 是否执行深度合并
        function extend(target, source, deep) {
            for (key in source)
                if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
    // source[key]是对象，而target[key]不是对象，则target[key]={}初始化一下，否则递归会出错的
                    if (isPlainObject(source[key]) && !isPlainObject(target[key]))
                        target[key] = {}

    // source[key] 是数组，而 target[key]不是数组，则 target[key] = []初始化一下，否则递归会出错的
                    if (isArray(source[key]) && !isArray(target[key]))
                        target[key] = []
                    // 执行递归
                    extend(target[key], source[key], deep)
                }
                // 不满足以上条件，说明 source[key] 是一般的值类型，直接赋值给 target 就是了
                else if (source[key] !== undefined) target[key] = source[key]
        }

        // Copy all but undefined properties from one or more
        // objects to the `target` object.
        $.extend = function(target){
            var deep, args = slice.call(arguments, 1);

            //第一个参数为boolean值时，表示是否深度合并
            if (typeof target == 'boolean') {
                deep = target;
                //target取第二个参数
                target = args.shift()
            }
            // 遍历后面的参数，都合并到target上
            args.forEach(function(arg){ extend(target, arg, deep) })
            return target
        }


