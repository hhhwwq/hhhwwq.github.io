---
title: some codes
date: 2019-12-27 15:36:05
tags: "JavaScript"
---


# 十段一定要会的代码


分别有promise封装ajax、Promise.all()、手写ajax、串行ajax请求处理、手写闭包、柯里化、节流防抖、bind底层、cookie封装、数组扁平化。

## 1.promise封装ajax

    const getJSON = function(url) {
      const promise = new Promise(function(resolve, reject){
        const handler = function() {
          if (this.readyState !== 4) {
            return;
          }
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error(this.statusText));
          }
        };
        const client = new XMLHttpRequest();
        client.open("GET", url);
        client.onreadystatechange = handler;
        client.responseType = "json";
        client.setRequestHeader("Accept", "application/json");
        client.send();
    
      });
    
      return promise;
    };
    
    getJSON("/posts.json").then(function(json) {
      console.log('Contents: ' + json);
    }, function(error) {
      console.error('出错了', error);
    });
    

`getJson`是对`XMLHttpRequest`对象的封装，用于发出一个针对`JSON`数据的`HTTP`请求，并且返回一个`Promise`对象。需要注意的是，在`getJSON`内部，`resolve`函数和`reject`函数调用时，都带有参数。`reject`函数的参数通常是`Error`对象的实例，表示抛出的错误；`resolve`函数的参数除了正常的值以为，还可能是另一个`Promise`实例。

## 2.promise.all()

    // 生成一个Promise对象的数组
    const promises = [2, 3, 5, 7, 11, 13].map(function (id) {
      return getJSON('/post/' + id + ".json");
    });
    
    Promise.all(promises).then(function (posts) {
      // ...
    }).catch(function(reason){
      // ...
    });
    

`promises`是包含 6 个 `Promise`实例的数组，只有这 6 个实例的状态都变成`fulfilled`，或者其中有一个变为`rejected`，才会调用`Promise.all`方法后面的回调函数。

## 3.手写ajax

    var Ajax = {
        get: function(url,fn){
            // XMLHttpRequest对象用于在后台与服务器交换数据
            var xhr=new XMLHttpRequest();
            xhr.open('GET',url,false);
            xhr.onreadystatechange=function(){
                // readyState == 4说明请求已完成
                if(xhr.readyState==4){
                    if(xhr.status==200 || xhr.status==304){
                        console.log(xhr.responseText);
                        fn.call(xhr.responseText);
                    }
                }
            }
            xhr.send();
        },
        
    
        // data应为'a=a1&b=b1'这种字符串格式，在jq里如果data为对象会自动将对象转成这种字符串格式
        post: function(url,data,fn){
            var xhr=new XMLHttpRequest();
            xhr.open('POST',url,false);
            // 添加http头，发送信息至服务器时内容编码类型
            xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');
            xhr.onreadystatechange=function(){
                if (xhr.readyState==4){
                    if (xhr.status==200 || xhr.status==304){
                        // console.log(xhr.responseText);
                        fn.call(xhr.responseText);
                    }
                }
            }
            xhr.send(data);
        }
    };
    

## 4.串行ajax请求处理

串行执行分为两种。

一种是用同步模式async：false，三个ajax请求连着写就可以了。

    $.ajax({
      url:"ajax请求1",
      async:false,
      success:function(data){
        console.log("ajax请求1 完成");
      }
    
    });
    $.ajax({
        url:"ajax请求2",
        async:false,
        success:function(data){
        console.log("ajax请求2 完成");
    });
    $.ajax({
        url:"ajax请求3",
        async:false,
        success:function(data){
        console.log("ajax请求3 完成");
    });
    
    

二是用异步模式async：ture，三个ajax请求嵌套写。

    $.ajax({
    url:"ajax请求1",
    async:true,
    success:function(data){
      console.log("ajax请求1 完成");
      $.ajax({
        url:"ajax请求2",
        async:true,
        success:function(data){
          console.log("ajax请求2 完成");
          $.ajax({
            url:"ajax请求3",
            async:true,
            success:function(data){
              console.log("ajax请求3 完成");
            }
          });
        }
      });
    }
    });
    

## 5.手写闭包

    var outerValue="out";//在全局作用域定义一个变量。
    var later;
    
    function outerFunction(){
      var innerValue="in";
      function innerFunction(){
        assert(outerValue==="out","i can see the out");
        assert(innerValue==="in","i can see the in");
      }
      later=innerFunction;
    }
    outerFunction();
    later();//通过later调用内部函数，我们不能直接调用内部函数，因为它的作用域被限制在外部函数outerFunction之内。
    

## 6.柯里化(currying)

函数柯里化用于**创建已经设置好了一个或多个参数的函数**，它的基本方法和函数绑定一样的：使用一个闭包返回一个函数。

    curry的主要工作就是将被返回函数的参数进行排序。
    function curry(fn){
      var args=Array.prototype.slice.call(arguments,1);//获取第一个参数之后的所有参数。（外部函数的参数）
      return function(){
        var innerArgs=Array.prototype.slice.call(arguments);//存放所有传入的参数。
        var finalArgs=args.concat(innerArgs);
        return fn.apply(null,finalArgs);//没有考虑到执行环境，所以第一个参数是null。
      }
    }
    

可以按照以下方式应用：

    function add(num1,num2){
      return num1+num2;
    }
    var curriedAdd=curry(add,5);
    alert(curriedAdd(3));//8
    

## 7.节流防抖

函数防抖：在事件被触发n秒后再执行回调，如果再这n秒内又被触发，则重新计时。

    function debounce(fn, delay) {
        //维护一个timer，用来记录当前执行函数状态
        let timer=null;
          return function () {
               //通过'this'和'arguments'获取函数的作用域和变量
              let context = this;
              let args = arguments;
              //清理正在执行的函数，并重新执行
              clearTimeout(timer);
              timer = setTimeout(function () {
                  fn.apply(context, args);
              }, delay);
          }
      }
      let flag=0;//记录当前函数调用次数
      //当前用户滚动时被调用的次数
      function foo(){
          flag++;
          console.log('number of calls: %d',flag);
      }
      //debounce中包装过我们的函数，过2秒触发一次
      document.body.addEventListener('scroll',debounce(foo,2000));
    

函数节流：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

    fucntion throttle(func,delay){
      let timer=null;
      return function(){
        let context=this;
        let args=arguments;
        if(!timer){
          timer=setTimeout(function(){
            func.apply(context,args);
            timer=null;
            },delay);
        }
      }
    }
    

## 8.bind底层

参考链接：[https://juejin.im/post/59093b1fa0bb9f006517b906](https://juejin.im/post/59093b1fa0bb9f006517b906)

    Function.prototype.bind2 = function (context) {
    
        if (typeof this !== "function") {
          throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
        }
    
        var self = this;
        var args = Array.prototype.slice.call(arguments, 1);
        var fNOP = function () {};
    
        var fbound = function () {
            self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments)));
        }
    
        fNOP.prototype = this.prototype;
        fbound.prototype = new fNOP();
    
        return fbound;
    
    }
    

## 9.cookie封装

            <script type="text/javascript">
            /*****设置cookie*****/
            function setCookie(name,value,iDay){
                var oDate = new Date();//获取日期毫秒数
                oDate.setDate(oDate.getDate()+iDay);//设置延期日
                document.cookie = name+'='+value+';expires='+oDate;//到这里的oDate是延期后的时间毫秒数
            }
            /*****获取cookie*****/
            function getCookie(name){
                var arr = document.cookie.split("; ");
                for(var i=0;i<arr.length;i++){
                    var arr2 = arr[i].split("=");
                    if(arr2[0]==name){
                        return arr2[1];
                    }
                }
                return ""
            }
            /*****移除cookie*****/
            function removeCookie(name){
                setCookie(name,1,-1);//让计算机以为这条数据昨天过期，自己删除本条数据。
            };
            /*****测试cookie*****/
            setCookie('123','321',1)
            setCookie('124','421',1)
            removeCookie('123');
            var m = getCookie('124');
            alert(m);
            document.write("<hr/>"+document.cookie);
            </script>
    

getCookie:传一个参数，就是要查找记录的name值，讲现有的cookie字符串进行切割扔个arr，此时的arr就是{name=1,name2=2,name3=3&hellip;}的一个object，就像一个json，此时，再遍历，将arr的每一个元素分别提取出来然后通过等号切割，扔个arr2，这样，arr2就成了俩值得数组，遍历一遍，就被扔进来一对，把扔进来的这对进行判断，如果他的名字等于传进来的要查找的参数值，那么arr2内部的第2个数值就是要找的名字对应值，把他弹出来。否则，遍历完了还没有，就弹回空或者其他的“没找到”等提示语。

## 10.数组扁平化

    /*实现一：递归 */
    function flatArray(arr) {
        var result = [];
        for (var i = 0; i < arr.length; i++) {
            if (Array.isArray(arr[i])) {
                result = result.concat(flatArray(arr[i]));
            } else {
                result.push(arr[i]);
            }
        }
        return result;
    }
    /*实现二：如果数组的元素均为数字，可以考虑使用toString()方法或者join()方法，再使用split方法转换为数组。*/
    function flatArray2(arr) {
        return arr.toString().split(',').map(item => +item);
    }
    /*实现三：使用ES6新增的扩展运算符 */
    function flatArray3(arr) {
        while (arr.some(item => Array.isArray(item))) {
            arr = [].concat(...arr);
        }
        return arr;
    }
    /*实现四：reduce */
    function flatArray4(arr) {
        return arr.reduce((result, item) => {
            return result.concat(Array.isArray(item) ? flatArray4(item) : item);
    
        }, []);
    }
    
