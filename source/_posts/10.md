---
title: apply，bind，call的区别；new；this；闭包 
date: 2019-10-16 18:40:53
tags: "HTTP"

---

apply，bind，call的区别；new；this；闭包 
========================================


5. apply、call、bind的区别 
--------------------------

-   三者的相同点：都是用来改变this的指向
-   区别

    -   call()和apply()的区别：

        1.相同点：都是调用一个对象的一个方法，用另一个对象替换当前对象（功能相同）

        例如:

        B.call(A, args1,args2); 即A对象调用B对象的方法。

        F.apply(G, arguments);即G对象应用F对象的方法。

        2.不同点：参数书写方式不同。

        call()：第一个参数是this要指向的对象，后面传入的是参数列表，参数可以是任意类型，当第一个参数为null、undefined的时候，默认指向window；

        apply()：第一个参数是this要指向的对象，第二个参数是数组。

        例如：

                var obj = {}//定义一个空的对象
                function f(x,y){
                console.log(x,y)
                console.log(this) //this是指obj
                }
                f.apply(obj,[1,2]) //后面的值需要用[]括起来
                f.call(obj,1,2) //直接写

    -   call()和bind()的区别：

        1.相同点：都是用来改变this的指向

        2.不同点：call()改过this的指向后，会再执行函数，bind()改过this后，不执行函数，会返回一个绑定新this的函数

                //例如：
                function f(){
                console.log("看我怎么被调用");
                console.log(this) //指向this
                }
                var obj = {};
                f.call(obj) //直接调用函数
                var g = f.bind(obj); //bind()不能调用函数
                g();  //此时才调用函数

    6. new的原理 
    ------------

**通过new创建对象经历4个步骤**

1、创建一个新对象；

2、将构造函数的作用域赋给新对象（因此this指向了这个新对象）；

3、执行构造函数中的代码(为这个新对象添加属性)；

4、返回新对象。

                function Person(name, age) {
                
                    this.name = name;
                
                    this.age = age;

                    this.job=job;
                
                    this.sayName = function() {
                
                        alert(this.name);
                    };
                
                }
                var person1 = new Person("yan",23,"teacher");
                var person2 = new Person("sun",23,"docter");

7. 如何正确判断this？ 
---------------------

### 1.谁作为拥有者调用它就指向谁 

        function a() { 
            console.log(this); 
        }
        var b  = {};
        b.hehe = a;
        b.hehe();
        //这时候this指向b//常见的就是绑定事件

### 2.bind谁就指向谁 

        function a() { 
            console.log(this); 
        }
        var b  = {};
        var c = {};
        b.hehe = a.bind(c);
        b.hehe();
        //这时候this指向c//如果你用bind的话

### 3.没有拥有者，直接调用，就指向window 

        function a() { 
            console.log(this); 
        }
        a();
        //this指向window

### 4.call谁就是谁，apply谁就是谁，其实bind就是通过call和apply实现的 

### 其中2覆盖掉1

8. 闭包及其作用 
---------------

-   闭包

    闭包是指有权访问另一个函数作用域中的变量的函数。

    创建闭包的常见方式就是在一个函数内部创建另一个函数。

    //闭包实际应用中主要用于封装变量，收敛权限。

-   作用

1.  匿名自执行函数

        <script type="text/javascript">
            (function (a) {
                console.log(a)
            })(3)     // 3
        </script>

    -   为什么要使用匿名函数自执行函数,好处是什么

    定义变量是需要加上var
    否则会默认添加到全局对象的属性上,或者别的函数可能误用这些变量；或者造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的),
    实际中有的函数只调用一次使用自执行函数也是很好的,

    我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，
    因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。

2.  缓存

        var CachedSearchBox = (function(){    
            var cache = {},    
            count = [];    
            return {    
            attachSearchBox : function(dsid){    
                if(dsid in cache){//如果结果在缓存中    
                    return cache[dsid];//直接返回缓存中的对象    
                }    
                var fsb = new uikit.webctrl.SearchBox(dsid);//新建    
                cache[dsid] = fsb;//更新缓存    
                if(count.length > 100){//保证缓存的大小<=100    
                    delete cache[count.shift()];    
                }    
                return fsb;          
            },    
                
            clearSearchBox : function(dsid){    
                if(dsid in cache){    
                    cache[dsid].clearSelection();      
                }    
            }    
            };    
        })();    
             
        CachedSearchBox.attachSearchBox("input1"); 

    这样，当我们第二次调用CachedSearchBox.attachSerachBox(“input1”)的时候，
    我们就可以从缓存中取道该对象，而不用再去创建一个新的searchbox对象。

3.  实现封装

        var person = function(){    
            //变量作用域为函数内部，外部无法访问    
            var name = "default";       
                
            return {    
            getName : function(){    
                return name;    
            },    
            setName : function(newName){    
                name = newName;    
            }    
            }    
        }();    
                
        console.log(person.name);//直接访问，结果为undefined    
        console.log(person.getName());  // default   
        person.setName("Tom");    
        console.log(person.getName());    // Tom

    在person之外的地方无法访问其内部的变量，而通过提供闭包的形式来访问。

4.  实现面向对象中的对象，传统的对象语言都提供类的模板机制，

        function Person(){    
            var name = "default";       
                
            return {    
            getName : function(){    
                return name;    
            },    
            setName : function(newName){    
                name = newName;    
            }    
            }    
        };    
                
                
        var john = Person();    
        console.log(john.getName());    // default
        john.setName("john");    
        console.log(john.getName());    // john
                
        var jack = Person();    
        console.log(jack.getName());    // default 
        jack.setName("jack");    
        console.log(jack.getName());    // jack

    john和jack都可以称为是Person这个类的实例，因为这两个实例对name这个成员的访问是独立的，互不影响的。


