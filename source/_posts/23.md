---
title: js处理异步的几种方式
date: 2019-12-24 15:36:05
tags: "JavaScript"
---


# js处理异步的几种方式


JavaScript语言的执行环境是“单线程”，这种模式容易因为某段耗时很长的任务而拖延整段程序的执行。

为了解决这个问题，JavaScript语言将任务的执行模式分成两种：同步和异步。

**同步模式**就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的，同步的。

**异步模式**非常重要，在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，异步模式甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。

下面是处理异步的几种方法：

## 一，回调函数（callback）

> A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.

回调是一个函数被作为一个参数传递到另一个函数里，在那个函数执行完再执行。（ 也即：B函数被作为参数传递到A函数里，在A函数执行完后再执行B ）

如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。

    function f1(callback){
        setTimeout(function(){
            //f1的任务代码
            callback();
        },1000);
    }
    //执行
    f1(f2)
    

采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。

回调函数是异步编程最基本的方法，其**优点**是简单，容易理解和部署，**缺点**是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱。而且每个任务只能指定一个回调函数。

**注意区分回调函数和异步，回调并不一定是异步，他们之间没有直接关系**

同步回调：

    function A(callback){
        console.log("I am A");
        callback();//调用该函数
    }
    function B(){
        console.log("I am B");
    }
    A(B);
    

## 二，事件监听

事件驱动模式也可以，任务的执行不取决于代码的顺序，而**取决于某个事件是否发生。**

    //on
    f1.on('done',f2);
    //或者
    function f1(){
        settimeout(function(){
           //...f1的任务代码
           f1.trigger('done');  //执行完成后，立即触发done事件，从而开始执行f2.
        },1000);
    }
    

这种方法的优点：容易理解，可以绑定**多个事件**，每一个事件可以指定多个回调函数，而且可以去**耦合，有利于实现模块化**。

缺点：整个程序都要变成事件驱动型，运行**流程会变得不清晰。**

### 事件监听方法：

**onclick**:

    element.onclick=function(){
       //处理函数
    }
    

优点：写法兼容到主流浏览器

缺点：当同一个element元素绑定多个事件时，只有最后一个事件会被添加，相当于一次只能添加一个事件；

**attachEvent和addEvenListener**:

    //IE:attachEvent;三个方法执行顺序：3-2-1；
    elment.attachEvent("onclick",handler1);
    elment.attachEvent("onclick",handler2);
    elment.attachEvent("onclick",handler3);
    //标准addEventListener;执行顺序：1-2-3
    elment.addEvenListener("click",handler1,false);
    elment.addEvenListener("click",handler2,false);
    elment.addEvenListener("click",handler3,false);
    

注意：该方法的第三个参数是冒泡获取，是一个布尔值：当为false时表示由里向外（冒泡），true表示由外向里（捕获）。

## 三，发布/订阅

假定存在一个信号中心，某个任务执行完成，就向信号中心“发布”一个信号，其他任务可以向信号中心“订阅”这个信号，从而知道什么时候自己可以开始执行。这就叫做“发布/订阅模式”，也称“观察者模式”。

    //jQuery的一个插件 Ben Alman的Tiny Pub/Sub
    jQuery.subscribe("done", f2);//f2向"信号中心"jQuery订阅"done"信号。
    jQuery.unsubscribe("done", f2);//取消订阅（unsubscribe）
    //或者
    function f1(){
    　　setTimeout(function () {
    　　　　// ...f1的任务代码
    　　　　jQuery.publish("done");//f1执行完成后，向"信号中心"jQuery发布"done"信号，从而引发f2的执行
    　　}, 1000);
    }
    

## 四，promise对象

1. 
promise对象是commonJS工作组提出的一种规范，一种模式，目的是为了异步编程提供统一接口。

2. 
**promise是一种模式，promise可以帮忙管理异步方式返回的代码**。他将代码进行封装并添加一个类似于事件处理的管理层。我们可以使用promise来注册代码，这些代码会在在promise成功或者失败后运行。

3. 
promise完成之后，对应的代码也会执行。我们可以注册任意数量的函数再成功或者失败后运行，也可以在任何时候注册事件处理程序。

4. 
promise有两种状态：1、等待（pending）；2、完成（settled）。
promise会一直处于等待状态，直到它所包装的异步调用返回/超时/结束。

5. 
这时候promise状态变成完成。完成状态分成两类：1、解决（resolved）；2、拒绝（rejected）

    //promise
    var p=new Promise(function(resolved))
    //在这里进行处理。也许可以使用ajax
    setTimeout(function(){
    var result=10*5;
    if(result===50){
      resolve(50);
    }else{
     reject(new Error('Bad Math'));
    }
    },1000);
    });
    p.then(function(result){
    console.log('Resolve with a values of %d',result);
    });
    p.catch(function(){
    console.error('Something went wrong');
    });
    

简单来讲，它的思想是：每一个异步任务返回一个promise对象，该对象有一个then方法，允许指定回调函数。
缺点：**编写和理解都难**

## 五，async/await

async 函数书写的方式跟我们普通的函数书写方式一样，只不过是前面多了一个 async 关键字，并且函数返回的是一个 Promise 对象，所接收的值就是函数 return 的值。

在 async 函数内部可以使用 await 命令，表示等待一个异步函数的返回。await 后面跟着的是一个 Promise 对象，如果不是的话，系统会调用 Promise.resolve() 方法，将其转为一个 resolve 的 Promise 的对象。

    function fn1 () {
      console.log('Function 1')
    }
    
    function fn2 () {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          console.log('Function 2')
          resolve()
        }, 500)
      })
    }
    
    function fn3 () {
      console.log('Function 3')
    }
    
    async function asyncFunArr () {
      fn1()
      await fn2()
      fn3()
    }
    
    asyncFunArr()
    
    // output =>
    // Function 1
    // Function 2
    // Function 3
    

